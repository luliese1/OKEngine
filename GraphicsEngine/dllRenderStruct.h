#pragma once
#include "dllDefine.h"

#define MAXIMUM_SHADER_RESOURCE_PER_MESH 8
#define MAXIMUM_RENDERTARGET_TEXTURE_PER_MESH 8
#define MAXIMUM_SAMPLER_RESOURCE_PER_MESH 4


struct GRAPHICENGINELIB_API RenderInfo
{
	UINT m_CubeMapID;
};
struct GRAPHICENGINELIB_API MeshInfo
{
	MeshInfo() : m_MeshId(0), m_subMeshId(0), m_MaterialID(0), m_TextureID(), m_TextureCnt(0), m_PassName(){}
	MeshInfo& operator =(const MeshInfo& info) = default;

	size_t  m_MeshId;
	UINT8 m_subMeshId;

	////텍스쳐 개수는 어쩌냐.. 흠.. 동적으로 생성해줄까
	size_t  m_MaterialID;

	size_t  m_TextureID[MAXIMUM_SHADER_RESOURCE_PER_MESH];
	UINT8 m_TextureCnt;

	std::wstring m_PassName;
};

// 자원의 출처
enum class GRAPHICENGINELIB_API SHADER_RESOURCE_SOURCE
{
	BACKBUFFER,
	PASS,
	PASSDEPTH,
	TEXTURE
};
enum class GRAPHICENGINELIB_API SHADER_RENDER_TARGET
{
	BACKBUFFER,
	PASS,
	OTHERPASS
};
//DIRECT11과 동일하게 맨뒤 NULL NULL을 넣어줘야한다.
struct GRAPHICENGINELIB_API GRAPHICSENGINE_SHADER_MACRO_DESC
{
	LPCSTR Name;
	LPCSTR Definition;
};
struct GRAPHICENGINELIB_API GRAPHICSENGINE_TEXTURE_DESC
{
	enum class TEXTURE_FORMAT {
		FORMAT_UNKNOWN = 0,
		FORMAT_R32G32B32A32_TYPELESS = 1,
		FORMAT_R32G32B32A32_FLOAT = 2,
		FORMAT_R32G32B32A32_UINT = 3,
		FORMAT_R32G32B32A32_SINT = 4,
		FORMAT_R32G32B32_TYPELESS = 5,
		FORMAT_R32G32B32_FLOAT = 6,
		FORMAT_R32G32B32_UINT = 7,
		FORMAT_R32G32B32_SINT = 8,
		FORMAT_R16G16B16A16_TYPELESS = 9,
		FORMAT_R16G16B16A16_FLOAT = 10,
		FORMAT_R16G16B16A16_UNORM = 11,
		FORMAT_R16G16B16A16_UINT = 12,
		FORMAT_R16G16B16A16_SNORM = 13,
		FORMAT_R16G16B16A16_SINT = 14,
		FORMAT_R32G32_TYPELESS = 15,
		FORMAT_R32G32_FLOAT = 16,
		FORMAT_R32G32_UINT = 17,
		FORMAT_R32G32_SINT = 18,
		FORMAT_R32G8X24_TYPELESS = 19,
		FORMAT_D32_FLOAT_S8X24_UINT = 20,
		FORMAT_R32_FLOAT_X8X24_TYPELESS = 21,
		FORMAT_X32_TYPELESS_G8X24_UINT = 22,
		FORMAT_R10G10B10A2_TYPELESS = 23,
		FORMAT_R10G10B10A2_UNORM = 24,
		FORMAT_R10G10B10A2_UINT = 25,
		FORMAT_R11G11B10_FLOAT = 26,
		FORMAT_R8G8B8A8_TYPELESS = 27,
		FORMAT_R8G8B8A8_UNORM = 28,
		FORMAT_R8G8B8A8_UNORM_SRGB = 29,
		FORMAT_R8G8B8A8_UINT = 30,
		FORMAT_R8G8B8A8_SNORM = 31,
		FORMAT_R8G8B8A8_SINT = 32,
		FORMAT_R16G16_TYPELESS = 33,
		FORMAT_R16G16_FLOAT = 34,
		FORMAT_R16G16_UNORM = 35,
		FORMAT_R16G16_UINT = 36,
		FORMAT_R16G16_SNORM = 37,
		FORMAT_R16G16_SINT = 38,
		FORMAT_R32_TYPELESS = 39,
		FORMAT_D32_FLOAT = 40,
		FORMAT_R32_FLOAT = 41,
		FORMAT_R32_UINT = 42,
		FORMAT_R32_SINT = 43,
		FORMAT_R24G8_TYPELESS = 44,
		FORMAT_D24_UNORM_S8_UINT = 45,
		FORMAT_R24_UNORM_X8_TYPELESS = 46,
		FORMAT_X24_TYPELESS_G8_UINT = 47,
		FORMAT_R8G8_TYPELESS = 48,
		FORMAT_R8G8_UNORM = 49,
		FORMAT_R8G8_UINT = 50,
		FORMAT_R8G8_SNORM = 51,
		FORMAT_R8G8_SINT = 52,
		FORMAT_R16_TYPELESS = 53,
		FORMAT_R16_FLOAT = 54,
		FORMAT_D16_UNORM = 55,
		FORMAT_R16_UNORM = 56,
		FORMAT_R16_UINT = 57,
		FORMAT_R16_SNORM = 58,
		FORMAT_R16_SINT = 59,
		FORMAT_R8_TYPELESS = 60,
		FORMAT_R8_UNORM = 61,
		FORMAT_R8_UINT = 62,
		FORMAT_R8_SNORM = 63,
		FORMAT_R8_SINT = 64,
		FORMAT_A8_UNORM = 65,
		FORMAT_R1_UNORM = 66,
		FORMAT_R9G9B9E5_SHAREDEXP = 67,
		FORMAT_R8G8_B8G8_UNORM = 68,
		FORMAT_G8R8_G8B8_UNORM = 69,
		FORMAT_BC1_TYPELESS = 70,
		FORMAT_BC1_UNORM = 71,
		FORMAT_BC1_UNORM_SRGB = 72,
		FORMAT_BC2_TYPELESS = 73,
		FORMAT_BC2_UNORM = 74,
		FORMAT_BC2_UNORM_SRGB = 75,
		FORMAT_BC3_TYPELESS = 76,
		FORMAT_BC3_UNORM = 77,
		FORMAT_BC3_UNORM_SRGB = 78,
		FORMAT_BC4_TYPELESS = 79,
		FORMAT_BC4_UNORM = 80,
		FORMAT_BC4_SNORM = 81,
		FORMAT_BC5_TYPELESS = 82,
		FORMAT_BC5_UNORM = 83,
		FORMAT_BC5_SNORM = 84,
		FORMAT_B5G6R5_UNORM = 85,
		FORMAT_B5G5R5A1_UNORM = 86,
		FORMAT_B8G8R8A8_UNORM = 87,
		FORMAT_B8G8R8X8_UNORM = 88,
		FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89,
		FORMAT_B8G8R8A8_TYPELESS = 90,
		FORMAT_B8G8R8A8_UNORM_SRGB = 91,
		FORMAT_B8G8R8X8_TYPELESS = 92,
		FORMAT_B8G8R8X8_UNORM_SRGB = 93,
		FORMAT_BC6H_TYPELESS = 94,
		FORMAT_BC6H_UF16 = 95,
		FORMAT_BC6H_SF16 = 96,
		FORMAT_BC7_TYPELESS = 97,
		FORMAT_BC7_UNORM = 98,
		FORMAT_BC7_UNORM_SRGB = 99,
		FORMAT_AYUV = 100,
		FORMAT_Y410 = 101,
		FORMAT_Y416 = 102,
		FORMAT_NV12 = 103,
		FORMAT_P010 = 104,
		FORMAT_P016 = 105,
		FORMAT_420_OPAQUE = 106,
		FORMAT_YUY2 = 107,
		FORMAT_Y210 = 108,
		FORMAT_Y216 = 109,
		FORMAT_NV11 = 110,
		FORMAT_AI44 = 111,
		FORMAT_IA44 = 112,
		FORMAT_P8 = 113,
		FORMAT_A8P8 = 114,
		FORMAT_B4G4R4A4_UNORM = 115,
		FORMAT_P208 = 130,
		FORMAT_V208 = 131,
		FORMAT_V408 = 132,
		FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE,
		FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE,
		FORMAT_FORCE_UINT = 0xffffffff
	};
	enum class TEXTURE_USAGE 
	{
		USAGE_DEFAULT = 0,
		USAGE_IMMUTABLE = 1,
		USAGE_DYNAMIC = 2,
		USAGE_STAGING = 3
	};

	UINT             m_MipLevels = 1;
	UINT             m_ArraySize = 1;
	TEXTURE_FORMAT   m_Format;
	TEXTURE_USAGE    m_Usage = TEXTURE_USAGE::USAGE_DEFAULT;
	UINT             m_BindFlags;
	UINT             m_CPUAccessFlags = 0;
	UINT             m_MiscFlags = 0;


	GRAPHICSENGINE_TEXTURE_DESC() = default;
	GRAPHICSENGINE_TEXTURE_DESC(TEXTURE_FORMAT f)
	{
		m_Format = f;
	}
};
struct GRAPHICENGINELIB_API GRAPHICSENGINE_SHADER_RESOURCE_INPUT_LAYOUT
{
	SHADER_RESOURCE_SOURCE m_ResourceSource;
	// BASICPASS or Texture을 사용한다면, m_ResourceName 은 필요하지 않다.
	std::wstring m_ResourceName;
	size_t m_ResourceIndex;
};
struct GRAPHICENGINELIB_API GRAPHICSENGINE_RENDER_TARGET_OUTPUT_LAYOUT
{
	SHADER_RENDER_TARGET m_ResourceSource;
	GRAPHICSENGINE_TEXTURE_DESC m_TextureDesc = GRAPHICSENGINE_TEXTURE_DESC(GRAPHICSENGINE_TEXTURE_DESC::TEXTURE_FORMAT::FORMAT_R8G8B8A8_UNORM);
};
struct GRAPHICENGINELIB_API GRAPHICSENGINE_DEPTH_STENCIL_BUFFER_LAYOUT
{
	GRAPHICSENGINE_TEXTURE_DESC m_TextureDesc = GRAPHICSENGINE_TEXTURE_DESC(GRAPHICSENGINE_TEXTURE_DESC::TEXTURE_FORMAT::FORMAT_D24_UNORM_S8_UINT);
};
struct GRAPHICENGINELIB_API GRAPHICSENGINE_SHADER_DESC
{
	GRAPHICSENGINE_SHADER_DESC(const std::wstring& shaderSetName, const std::wstring& VSPath, const std::wstring& PSPath, GRAPHICSENGINE_SHADER_MACRO_DESC* ShaderMacro, UINT ShaderMacroCnt);

	std::wstring m_ShaderSetName;

	std::wstring m_VertexShaderPath;
	std::wstring m_PixelShaderPath;

	//쉐이더 매크로는 DX와 똑같은 형식으로 만들어서 알아서 잘 만들어주어서 넣어주자.
	GRAPHICSENGINE_SHADER_MACRO_DESC* m_ShaderMacro;
	UINT m_ShaderMacroCnt;
};
struct GRAPHICENGINELIB_API GRAPHICSENGINE_PASS_DESC
{
	std::wstring m_PassName;
	//MRT로 뽑힌 데이터(RenderPass)를 바인딩 해야한다. 
	//다른패스에서 나온 텍스쳐로 작업하는 것은 일단 배제한다.. basic pass에서만 꺼내쓴다.
	//UINT m_InputTexturesCount;  // 사용되는 SRV 텍스쳐의 개수이다.. 알아서 잘 넣자...

	int m_TextureWidth = -1; // 0보다 작을시는 스크린사이즈로 
	int m_TextureHeight = -1; // 0보다 작을시는 스크린사이즈로

	//결과적으로 나오는 텍스쳐들
	GRAPHICSENGINE_RENDER_TARGET_OUTPUT_LAYOUT* m_RenderTargetLayout;
	UINT m_OutputTexturesCount; // 사용되는 RTV 텍스쳐의 개수이다... 최대 8개까지 가능하다

	GRAPHICSENGINE_SHADER_DESC* m_ShaderDesc;
	UINT m_ShaderCount;

	GRAPHICSENGINE_DEPTH_STENCIL_BUFFER_LAYOUT m_DepthStencilBufferLayout;

	std::wstring m_RasterizerStateName;
};
struct GRAPHICENGINELIB_API GRAPHICSENGINE_RASTERIZER_DESC
{
	enum class eFillMode 
	{
		WIRE = 2,
		SOLID = 3
	};

	enum class eCullMode 
	{
		CULL_NONE = 1,
		CULL_FRONT = 2,
		CULL_BACK = 3
	};

	eFillMode m_FillMode = eFillMode::SOLID;
	eCullMode m_CullMode = eCullMode::CULL_NONE;

	int m_DepthBias = 0;
	float m_DepthBiasClamp = 0.000f;
	float m_SlopeScaledDepthBias = 0.000f;

	bool m_DepthClipEnable = true;
	bool m_ScissorEnable = true;
	bool m_MultiSampleEnable = true;
	bool m_AntialiasedLineEnable = true;
};
struct GRAPHICENGINELIB_API GRAPHICSENGINE_ENGINE_DESC
{
	long instance;
	long handle;

	int ScreenWidth;
	int ScreenHeight;
};
//엔진을 생성할때 기본적으로 필요한 데이터들을 여기다 몰아넣자.
